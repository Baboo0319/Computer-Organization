$date
   Sun Dec  1 23:07:02 2024
$end
$version
  2019.2
$end
$timescale
  1ps
$end
$scope module basys_sim $end
$var reg 1 ! CLK $end
$var reg 1 " RST $end
$var reg 1 # CLKButton $end
$var reg 2 $ SW [1:0] $end
$var integer 32 % i $end
$scope module test $end
$var wire 1 & CLKButton $end
$var wire 1 ' BasysCLK $end
$var wire 1 ( RST_Button $end
$var wire 2 ) SW_in [1:0] $end
$var wire 8 * SegOut [7:0] $end
$var wire 4 + Bits [3:0] $end
$var wire 5 , RsAddr [4:0] $end
$var wire 5 - RtAddr [4:0] $end
$var wire 32 . RsData [31:0] $end
$var wire 32 / RtData [31:0] $end
$var wire 32 0 ALUResult [31:0] $end
$var wire 32 1 DBData [31:0] $end
$var wire 32 2 curPC [31:0] $end
$var wire 32 3 nextPC [31:0] $end
$var wire 1 4 CPUCLK $end
$var wire 1 5 Div_CLK $end
$var wire 4 6 SegIn [3:0] $end
$var wire 16 7 display_data [15:0] $end
$scope module CPU $end
$var wire 1 4 CLK $end
$var wire 1 ( Reset $end
$var wire 5 , rs [4:0] $end
$var wire 5 - rt [4:0] $end
$var wire 6 8 Opcode [5:0] $end
$var wire 32 . Out1 [31:0] $end
$var wire 32 / Out2 [31:0] $end
$var wire 32 2 curPC [31:0] $end
$var wire 32 3 nextPC [31:0] $end
$var wire 32 0 Result [31:0] $end
$var wire 32 1 DBData [31:0] $end
$var wire 3 9 ALUOp [2:0] $end
$var wire 32 : Extout [31:0] $end
$var wire 32 ; DMOut [31:0] $end
$var wire 16 < Immediate [15:0] $end
$var wire 5 = rd [4:0] $end
$var wire 5 > sa [4:0] $end
$var wire 32 ? JumpPC [31:0] $end
$var wire 1 @ zero $end
$var wire 1 A PCWre $end
$var wire 1 B ALUSrcA $end
$var wire 1 C ALUSrcB $end
$var wire 1 D DBDataSrc $end
$var wire 1 E ReWre $end
$var wire 1 F InsMemRW $end
$var wire 1 G RD $end
$var wire 1 H WR $end
$var wire 1 I ExtSel $end
$var wire 1 J RegDst $end
$var wire 2 K PCSrc [1:0] $end
$var wire 4 L PC4 [3:0] $end
$scope module alu $end
$var wire 32 . ReadData1 [31:0] $end
$var wire 32 / ReadData2 [31:0] $end
$var wire 32 : Ext [31:0] $end
$var wire 5 > Sa [4:0] $end
$var wire 3 9 ALUop [2:0] $end
$var wire 1 B ALUSrcA $end
$var wire 1 C ALUSrcB $end
$var wire 1 @ zero $end
$var reg 32 M Result [31:0] $end
$var wire 32 N InA [31:0] $end
$var wire 32 O InB [31:0] $end
$upscope $end
$scope module pc $end
$var wire 1 4 CLK $end
$var wire 1 ( Reset $end
$var wire 1 A PCWre $end
$var wire 2 K PCSrc [1:0] $end
$var wire 16 < Immediate [15:0] $end
$var wire 32 ? JumpPC [31:0] $end
$var reg 32 P Address [31:0] $end
$var wire 32 3 nextPC [31:0] $end
$var wire 4 L PC4 [3:0] $end
$upscope $end
$scope module CU $end
$var wire 6 8 OpCode [5:0] $end
$var wire 1 @ zero $end
$var wire 1 A PCWre $end
$var wire 1 B ALUSrcA $end
$var wire 1 C ALUSrcB $end
$var wire 1 D DBDataSrc $end
$var wire 1 E RegWre $end
$var wire 1 F InsMemRW $end
$var wire 1 G RD $end
$var wire 1 H WR $end
$var wire 1 I ExtSel $end
$var wire 1 J RegDst $end
$var wire 2 K PCSrc [1:0] $end
$var wire 3 9 ALUOp [2:0] $end
$upscope $end
$scope module DM $end
$var wire 1 4 CLK $end
$var wire 32 0 DAddr [31:0] $end
$var wire 32 / DataIn [31:0] $end
$var wire 1 G RD $end
$var wire 1 H WR $end
$var wire 32 ; DataOut [31:0] $end
$var wire 32 Q address [31:0] $end
$upscope $end
$scope module IM $end
$var wire 4 L PC4 [3:0] $end
$var wire 32 2 IAddr [31:0] $end
$var wire 1 F RW $end
$var wire 6 8 op [5:0] $end
$var wire 5 , rs [4:0] $end
$var wire 5 - rt [4:0] $end
$var wire 5 = rd [4:0] $end
$var wire 16 < Immediate [15:0] $end
$var wire 5 > Sa [4:0] $end
$var wire 32 ? JumpPC [31:0] $end
$var reg 32 R IDataOut [31:0] $end
$upscope $end
$scope module RF $end
$var wire 1 4 CLK $end
$var wire 1 J RegDst $end
$var wire 1 E RegWre $end
$var wire 1 D DBDataSrc $end
$var wire 6 8 Opcode [5:0] $end
$var wire 5 , rs [4:0] $end
$var wire 5 - rt [4:0] $end
$var wire 5 = rd [4:0] $end
$var wire 11 S im [10:0] $end
$var wire 32 0 dataFromALU [31:0] $end
$var wire 32 ; dataFromRW [31:0] $end
$var wire 32 . Data1 [31:0] $end
$var wire 32 / Data2 [31:0] $end
$var wire 32 1 writeData [31:0] $end
$var wire 5 T writeReg [4:0] $end
$var integer 32 U i $end
$upscope $end
$scope module SZE $end
$var wire 16 < Immediate [15:0] $end
$var wire 1 I ExtSel $end
$var wire 32 : Out [31:0] $end
$upscope $end
$upscope $end
$scope module clk_slow $end
$var wire 1 ' CLK_100mhz $end
$var reg 1 V CLK_slow $end
$var reg 32 W count [31:0] $end
$var reg 32 X N [31:0] $end
$upscope $end
$scope module display_led $end
$var wire 4 6 display_data [3:0] $end
$var reg 8 Y dispcode [7:0] $end
$upscope $end
$scope module select $end
$var wire 16 Z In1 [15:0] $end
$var wire 16 [ In2 [15:0] $end
$var wire 16 \ In3 [15:0] $end
$var wire 16 ] In4 [15:0] $end
$var wire 2 ) SelectCode [1:0] $end
$var reg 16 ^ DataOut [15:0] $end
$upscope $end
$scope module transfer $end
$var wire 1 5 CLK $end
$var wire 16 7 In [15:0] $end
$var reg 4 _ Out [3:0] $end
$var reg 4 ` Bit [3:0] $end
$var integer 32 a i $end
$upscope $end
$scope module keyboard $end
$var wire 1 & Button $end
$var wire 1 ' BasysCLK $end
$var reg 1 b CPUCLK $end
$var reg 32 c debounce_counter [31:0] $end
$var reg 1 d button_debounced $end
$var reg 1 e button_previous_state $end
$var reg 1 f button_current_state $end
$var reg 1 g pulse_active $end
$var wire 1 h button_edge $end
$var parameter 32 i DEBOUNCE_COUNT [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0!
0"
0#
b0 $
bx %
0&
0'
0(
b0 )
bx *
b1110 +
b0 ,
b1 -
b0 .
b0 /
b1000 0
b1000 1
b0 2
b100 3
x4
05
bx 6
b100 7
b10 8
b0 9
b1000 :
bz ;
b1000 <
b0 =
b0 >
b1000000000010000000000001000 ?
0@
1A
0B
1C
0D
1E
1F
1G
1H
1I
0J
b0 K
b0 L
b1000 M
b0 N
b1000 O
b0 P
b100000 Q
b1000000000010000000000001000 R
bz S
b1 T
b100000 U
0V
b0 W
b1100001101010000 X
bx Y
b100 Z
b0 [
b100000000 \
b100000001000 ]
b100 ^
bx _
b1110 `
b1 a
xb
bx c
xd
xe
xf
xg
xh
b110000110101000 i
$end
#50000
1"
b0 %
1(
#150000
1!
1#
b1 %
1&
1'
b1 W
1f
#250000
0!
b10 %
0'
#350000
1!
b11 %
1'
b10 W
1e
0h
#450000
0!
b100 %
0'
#550000
1!
b101 %
1'
b11 W
#650000
0!
b110 %
0'
#750000
1!
b111 %
1'
b100 W
#850000
0!
b1000 %
0'
#950000
1!
b1001 %
1'
b101 W
